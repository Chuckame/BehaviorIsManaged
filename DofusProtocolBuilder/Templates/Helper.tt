<#@ assembly name="System.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="DofusProtocolBuilder" #>
<#@ import namespace="DofusProtocolBuilder.Parsing" #>
<#@ import namespace="DofusProtocolBuilder.XmlPatterns" #><#+
void WriteField(FieldInfo field)
{
	switch (field.Modifiers)
	{
		case AccessModifiers.Public:
			Write("public ");
			break;
		case AccessModifiers.Protected:
			Write("protected ");
			break;
		case AccessModifiers.Private:
			Write("private ");
			break;
		case AccessModifiers.Internal:
			Write("internal ");
			break;
	}

	if (field.IsConst)
	{
		Write("const ");
	}

	if (field.IsStatic)
	{
		Write("static ");
	}

	Write(field.Type + " ");
	Write(field.Name);

	if (!string.IsNullOrEmpty(field.Value))
	{
		Write(" = " + field.Value);
	}

	Write(";");
	WriteLine("");
}

void WriteField(XmlField field)
{
	WriteLine("public {0} {1};", GetRealType(field.Type), field.Name);
} 
    
XmlField[] GetHierarchyFields(XmlMessage message)
{
	if (message.Heritage == string.Empty ||
        message.Heritage == "Message")
		return new XmlField[0];

    var baseMessage = Program.Configuration.XmlMessagesProfile.SearchXmlPattern(message.Heritage);

	if (baseMessage == null)
        return new XmlField[0];

    return GetHierarchyFields(baseMessage).Concat(baseMessage.Fields).ToArray();
}

XmlField[] GetHierarchyFields(XmlType type)
{
    if (type.Heritage == string.Empty ||
        type.Heritage == "Object")
        return new XmlField[0];

    var baseType = Program.Configuration.XmlTypesProfile.SearchXmlPattern(type.Heritage);

    if (baseType == null)
        return new XmlField[0];

    return GetHierarchyFields(baseType).Concat(baseType.Fields).ToArray();
}
    
void WriteIOMethodStatements(IEnumerable<XmlField> fields, bool serializeMethod)
{
	bool limitDefined = false;
    int? flagsCount = null;
    int? lastFlagOffset = null;
    foreach(var field in fields)
    {
		string limit = field.Limit;
		string type = field.Type;
		string name = field.Name;

		bool array = false;

		if (type.EndsWith("[]"))
		{
            array = true;
            
			if (string.IsNullOrEmpty(limit))
			{
				if (!serializeMethod)
				{
					WriteLine((limitDefined ? string.Empty : "int ") + "limit = reader.readUInt16();");
					limitDefined = true;
				}

				limit = "limit";

				if (serializeMethod)
				{
					WriteLine("writer.writeUInt16(" + name + ".length);");
				}
			}

			type = type.Substring(0, type.Length - 2);

			if (!serializeMethod)
			{
                WriteLine(string.Format("{0} = new {1}[{2}];", name, GetRealType(type), limit));
				WriteLine("for (int i = 0; i < {0}; i++) {{", limit);
				PushIndent("    ");

                name += "[i]";
			}
			else
			{
				WriteLine("for ({0} entry : {1}) {{", GetRealType(type), field.Name);
				PushIndent("    ");

                name = "entry";
			}
		}

		if (serializeMethod &&
			(lastFlagOffset.HasValue && flagsCount.HasValue) &&
			(lastFlagOffset.Value >= 7 || !type.StartsWith("flag") ))
		{
			WriteLine("writer.writeUInt16(flag" + flagsCount + ");");
			lastFlagOffset = null;
		}

		if (type.StartsWith("flag"))
		{
			Match match = Regex.Match(type, @"flag\((\d+)\)");

			if (match.Success)
			{
				if (!lastFlagOffset.HasValue || lastFlagOffset.Value >= 7)
				{
					flagsCount = flagsCount.HasValue ? flagsCount + 1 : 1;

					if (serializeMethod)
						WriteLine("short flag" + flagsCount + " = 0;");
					else
						WriteLine("short flag" + flagsCount + " = reader.readUInt8();");
				}

				int flagOffset = int.Parse(match.Groups[1].Value);
				lastFlagOffset = flagOffset;

				if (serializeMethod)
					WriteLine(string.Format("flag{0} = BooleanByteWrapper.setFlag(flag{0}, {1}, {2});", flagsCount, flagOffset, name));
				else
					WriteLine(string.Format("{0} = BooleanByteWrapper.getFlag(flag{1}, {2});", name, flagsCount, flagOffset));
			}
		}
		else if (type.StartsWith("Types."))
		{
			if (serializeMethod)
				WriteLine(string.Format("{0}.serialize(writer);", name));
			else
			{
				WriteLine(string.Format("{0} = new {1}();", name, type.Replace("Types.", "")));
				WriteLine(string.Format("{0}.deserialize(reader);", name));
			}
		}
		else if (type.StartsWith("instance of"))
		{
         
			if (serializeMethod)
			{
				WriteLine(string.Format("writer.writeInt16({0}.getProtocolId());", name));
				WriteLine(string.Format("{0}.serialize(writer);", name));
			}
			else
			{            
				Match match = Regex.Match(type, @"instance of ([\w\d_\.]+)");

				if (match.Success)
				{  
					string instanceType = match.Groups[1].Value.Replace("Types.", "");
                    
					WriteLine(string.Format("{0} = ({1}) ProtocolTypeManager.getInstance().build(reader.readInt16()).get();", name, instanceType));
					WriteLine(string.Format("{0}.deserialize(reader);", name));
				}
				else
					Error(string.Format("Type {0} doesn't match 'instance of ([\\w\\d_\\.]+)'", type));
			}
		}
		else
		{
			if (serializeMethod)
				WriteLine(string.Format("writer.write{0}({1});", GetIOMethodTypeName(type), name));
			else
				WriteLine(string.Format("{0} = reader.read{1}();", name, GetIOMethodTypeName(type)));
		}
        
		//if (!string.IsNullOrEmpty(field.Condition))
		//{
		//	if (!serializeMethod)
		//	{
		//		WriteLine("if ({0}) {{", field.Condition);
		//		PushIndent("    ");
		//		WriteLine("throw new IllegalStateException(\"Forbidden value on {0} = \" + {0} + \", " + 
		//			"it doesn't respect the following condition : {1}\");", name, field.Condition);
		//		PopIndent();
		//		WriteLine("}");
		//	}
		//}

		if (array)
		{
			PopIndent();
            WriteLine("}");
		}
    }
        
    if (lastFlagOffset.HasValue)
    {
        if (serializeMethod)
			WriteLine("writer.writeUInt8(flag" + flagsCount + ");");
    }
}

string GetRealType(string rawType)
{
    if (rawType.StartsWith("instance of "))
        rawType = rawType.Replace("instance of ", "");

    var match = Regex.Match(rawType, @"([\.\w\d_]+)\[\]");

    if (match.Success)
    {
        return GetRealType(match.Groups[1].Value) + "[]";
    }

    if (rawType.StartsWith("flag"))
        return "boolean";

    if (rawType.Contains("Types."))
        return rawType.Replace("Types.", "");

    switch (rawType)
    {
        case "utf":    return "String";
        case "sbyte":  return "byte";
        case "byte":   return "short";
        case "ushort": return "int";
        case "uint":   return "long";
        case "ulong":  return "BigInteger";
        default:       return rawType;
    }
}
    
string GetIOMethodTypeName(string rawType)
{
	switch (rawType) {
		case "sbyte":  return "Int8";
		case "byte":   return "UInt8";
		case "short":  return "Int16";
		case "ushort": return "UInt16";
		case "int":    return "Int32";
		case "uint":   return "UInt32";
		case "long":   return "Int64";
		case "ulong":  return "UInt64";
    }

    if (rawType.StartsWith("instance of "))
        rawType = rawType.Replace("instance of ", "");

    char[] letters = rawType.ToCharArray();

    if (rawType == "utf")
        return "UTF";
    if (rawType.StartsWith("u") || rawType == "sbyte")
    {
        letters[0] = char.ToUpper(letters[0]);
        letters[1] = char.ToUpper(letters[1]);

        return new string(letters);
    }


    letters[0] = char.ToUpper(letters[0]);

    return new string(letters);
}
#>